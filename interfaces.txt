They give us the ability to describe object types.

Let's try to create a type called User, which:
  1. If it is a human user, will have a full name property.
  2. If it is a AI agent, will have a model name property.

If we describe them using regular object types:

type User = {
  name: string,
  id: string | number,
  fullName?: string,
  modelName?: string
};

let humanUser: User = {name: "Nik", id: "123", fullName: "Nik Nik Nik"};
let AiAgent: User = {name: "NikModel", id: "123", modelName: "Nik.1.2.3"};

The use of optional properties everywhere is not the best coding practice, so we use interfaces.

interface User = {
  name: string; // semi-colon instead of commas
  id: string | number;
}

interface Human extends User {
  fullName: string;
}

interface Agent extends User {
  modelName: string;
}

It is generally recommended to use an interface for objects, as they are faster and more flexible.

We can also write Asynchronous code which returns promises, with TS.

Type Parameters:
const promisedNum: Promise<number> = Promise.resolve(5);
const promisedStr: Promise<string> = Promise.resolve('5');
const brokenPromise: Promise<number> = Promise.resolve(null); // Error!

The type in between the angle brackets is the type parameter.
TS knows what to expect, and alerts us if a different type can potentially be returned.

Generic Types:
Assume you do not want to create so many type params like the example above. We
  can use a generic type instead:

type Nullable<T> = T | null; // This means the Nullable generic is of type "T" or type "null"

let nullishNum: Nullable<number> = 5;
nullishNum = 4; // OK
nullishNum = null; // OK

let stringishNull: Nullable<string> = "hello";

let objOrNot: Nullable< {property: string} >;
objOrNot = {property: "hello"}; // OK
objOrNot = null; // OK
objOrNot = undefined; // NOT OK

type User = {
  name: string;
  email: string;
  id: number;
}

TS also provides us with in built Generics.
Examples: 
  1. Readonly<User>: Essentially adds the readonly keyword before the variable. We will not be able to modify the initial values.
  2. Partial<User>: Essentially adds the ? symbol after the variable. Now all the options are not required.
  3. Pick<User, 'id'>: Makes a more specific subset of the type (in this case, an object with just the id field).
  4. Omit<User, 'email'>: Similar to above, opposite function (the object formed will exclude email).

any and @ts-ignore:
any is a type that allows you to store any type in your variable.

// @ts-ignore 
The above is a comment directive that tells the TSC compiler to ignore till the directive ends.

