JS types are: 
  1. Dynamic (Types are decided as code is running) 
  2. Weak (Types are often coerced so JS can work with it)

Examples:
let elevenString = '1' + 1; // '11'
let zero = '1' - 1; // 0
let emptyString = [] + []; // ''
let objectObject = [] + {}; // '[object Object]'

Typescript is a superset of JS. It has more features.
This means that all JS code can be converted to TS, but TS code cannot be converted to JS.

Types is TS are static and strong.

Typescript code compiles to JS. JS code is interpreted. So both interpreted and compiled is happening.

TS can be useful as a Dev tool, by providing autocompletion, hints etc.
TS can also generate JS code for various targets/platforms.

The type of a variable in TS is decided during variable initialization. After this initial type, it cannot change.


Type annotations:
let n: number = 55;
console.log(n);

let x: string;
x = "hello";
console.log(x);

We use variableName colon(:) typeName(string, number etc) to annotate a variable.

let n: number = 1;
let s: string = 'hi';
let b: boolean = true;
let missing: undefined = undefined;
let nothing: null = null;

We can also have literal types in TS:

let option: 'alive' | 'dead'
option = 'alive' // OK
option = 'dead' // OK
option = 'chilling' // Not allowed

let option: 'alive' | 'dead' | 1024
option = 'alive' // OK
option = 'dead' // OK
option = 1024 // OK
option = 'chilling' // Not allowed
option = 1025 // Not allowed
i.e, types are looser, but they have to be one of the specified values

Typed functions:

function add(a: number, b: number): number {
    return (a + b);
}

add(140, 60); // 200
add('oh', 'no'); // Error!

const x = (a: number, b: number): number => {
  return (a + b);
}

Typed Arrays:
let digits: number[] = [1,2,3];
digits.push(1); // OK
digits.push("Hello"); // NOT OK

let example: any[] = [1, "hello", "bye"] // OK

Typed Objects:

let user: {name: string, age: number}
user = {name: "Nik", age: 25}

user.name = "NNIIK" // OK
user.age = 24 // OK

user.name = 1; // NOT OK

We can also have optional properties:

let user = {name:string, age:number, color?:string}; // This means the color property can be a string or undefined.

user = {name: "Nikhil", age: 25}; // OK

let user: {name: string, age: number} // if we do not explicitly declare types like this, TS 
  // will implicitly place types on them. The reason for this type of declaration is to include optional types.

Union Types:
let option: 'alive' | 'dead' | 1024 // option can be one of these options.

let option: string | null // option can be a string or null.

Suppose we wanted to create a variable that can store a number, or an array of numbers:

let numberOrArray: number | number[]
numberOrArray = 9;
numberOrArray = [9];
numberOrArray.push(10);
console.log(numberOrArray); // This is valid

Suppose you wanted a combination array, of numbers and strings, but nothing else. We cannot use any[] here:

let numsOrStrings: (number | string)[]
numsOrStrings = [10, "Twenty", "30"] // Valid


Type guards:
Example of writing safe code:
  let elemOrNull: HTMLElement | null;
  elemOrNull = document.getElementById('might-exist');
  elemOrNull.addEventListener('click', () => {
      console.log("will this work?");
  }); // Error!

  if (elemOrNull === null) {
      console.log("not found");
  } else {
      elemOrNull.addEventListener('click', () => {
          console.log("found");
      })
}

Typescript will give us an error if we do not add an if..else check.

Type aliases:

Instead of always having to write:

let strExample: string | number | null;

We can write:
type Example = string | number | null;
let strExample = Example;

type StringOrNumber = string | number;

type LogLevel = 'log' | 'error' | 'warn'; // For literal strings

type User = {
    id: string,
    name: string,
    color?: string
}
let newUser: User;
newUser = {id: "123", name: "Nikhil"};
console.log(newUser);

Type aliases allow us to create a "variable for our types"

Use type aliases as often as possible. Changing them in one place will take care of your
  whole code base.
